{
  "name": "usb",
  "description": "Library to access USB devices",
  "keywords": [
    "usb",
    "hardware"
  ],
  "author": {
    "name": "Nonolith Labs",
    "url": "http://www.nonolithlabs.com"
  },
  "contributors": [
    {
      "name": "Kevin Mehall",
      "email": "km@kevinmehall.net",
      "url": "http://kevinmehall.net"
    },
    {
      "name": "Tim Ryan",
      "email": "tim@technical.io",
      "url": "http://timryan.org"
    },
    {
      "name": "Christopher Klein"
    }
  ],
  "version": "1.1.2",
  "engines": {
    "node": ">=0.12.x"
  },
  "main": "./usb",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nonolith/node-usb.git"
  },
  "scripts": {
    "install": "node-pre-gyp install --fallback-to-build",
    "test": "mocha --compilers coffee:coffee-script --grep Module",
    "full-test": "mocha --compilers coffee:coffee-script",
    "valgrind": "coffee -c test/usb.coffee; valgrind --leak-check=full --show-possibly-lost=no node --expose-gc --trace-gc node_modules/mocha/bin/_mocha -R spec"
  },
  "binary": {
    "module_name": "usb_bindings",
    "module_path": "./src/binding",
    "host": "https://tessel-builds.s3-us-west-2.amazonaws.com",
    "remote_path": "./pre-gyp/{name}/v{version}"
  },
  "dependencies": {
    "nan": "^2.1.0",
    "node-pre-gyp": "^0.6.13"
  },
  "devDependencies": {
    "coffee-script": "~1.6.2",
    "mocha": "~1.8.2",
    "aws-sdk": "~2.0.0-rc.15"
  },
  "license": "MIT",
  "readme": "USB Library for Node.JS\n===============================\n\n**POSIX:** [![Build Status](https://travis-ci.org/nonolith/node-usb.svg?branch=tcr-usb)](https://travis-ci.org/nonolith/node-usb) &nbsp;&nbsp;&nbsp; **Windows:** [![Build status](https://ci.appveyor.com/api/projects/status/b23kn1pi386nguya/branch/master)](https://ci.appveyor.com/project/kevinmehall/node-usb/branch/master)\n\nNode.JS library for communicating with USB devices in JavaScript / CoffeeScript.\n\nThis is a refactoring / rewrite of Christopher Klein's [node-usb](https://github.com/schakko/node-usb). The API is not compatible (hopefully you find it an improvement).\n\nIt's based entirely on libusb's asynchronous API for better efficiency, and provides a stream API for continuously streaming data or events.\n\nInstallation\n============\n\nLibusb is included as a submodule. On Linux, you'll need libudev to build libusb. On Ubuntu/Debian: `sudo apt-get install build-essential libudev-dev`\n\nThen, just run\n\n\tnpm install usb\n\nto install from npm. See the bottom of this page for instructions for building from a git checkout.\n\n### Windows\nUse [Zadig](http://sourceforge.net/projects/libwdi/files/zadig/) to install the WinUSB driver for your USB device. Otherwise you will get `LIBUSB_ERROR_NOT_SUPPORTED` when attempting to open devices.\n\n\nAPI\n===\n\n\tvar usb = require('usb')\n\nusb\n---\n\nTop-level object.\n\n### usb.getDeviceList()\nReturn a list of `Device` objects for the USB devices attached to the system.\n\n### usb.findByIds(vid, pid)\nConvenience method to get the first device with the specified VID and PID, or `undefined` if no such device is present.\n\n### usb.LIBUSB_*\nConstant properties from libusb\n\n### usb.setDebugLevel(level : int)\nSet the libusb debug level (between 0 and 4)\n\nDevice\n------\n\nRepresents a USB device.\n\n### .busNumber\nInteger USB device number\n\n### .deviceAddress\nInteger USB device address\n\n### .portNumbers\nArray containing the USB device port numbers\n\n### .deviceDescriptor\nObject with properties for the fields of the device descriptor:\n\n  - bLength\n  - bDescriptorType\n  - bcdUSB\n  - bDeviceClass\n  - bDeviceSubClass\n  - bDeviceProtocol\n  - bMaxPacketSize0\n  - idVendor\n  - idProduct\n  - bcdDevice\n  - iManufacturer\n  - iProduct\n  - iSerialNumber\n  - bNumConfigurations\n\n### .configDescriptor\nObject with properties for the fields of the configuration descriptor:\n\n  - bLength\n  - bDescriptorType\n  - wTotalLength\n  - bNumInterfaces\n  - bConfigurationValue\n  - iConfiguration\n  - bmAttributes\n  - bMaxPower\n  - extra (Buffer containing any extra data or additional descriptors)\n\n### .open()\n\nOpen the device. All methods below require the device to be open before use.\n\n### .close()\n\nClose the device.\n\n### .controlTransfer(bmRequestType, bRequest, wValue, wIndex, data_or_length, callback(error, data))\n\nPerform a control transfer with `libusb_control_transfer`.\n\nParameter `data_or_length` can be a integer length for an IN transfer, or a Buffer for an out transfer. The type must match the direction specified in the MSB of bmRequestType.\n\nThe `data` parameter of the callback is always undefined for OUT transfers, or will be passed a Buffer for IN transfers.\n\n### .setConfiguration(id, callback(error))\nSet the device configuration to something other than the default (0). To use this, first call `.open(false)` (which tells it not to auto configure), then before claiming an interface, call this method.\n\n### .getStringDescriptor(index, callback(error, data))\nPerform a control transfer to retrieve a string descriptor\n\n### .interface(interface)\nReturn the interface with the specified interface number.\n\n### .interfaces\nList of Interface objects for the interfaces of the default configuration of the device.\n\n### .timeout\nTimeout in milliseconds to use for control transfers.\n\n### .reset(callback(error))\nPerforms a reset of the device. Callback is called when complete.\n\n\nInterface\n---------\n\n### .endpoint(address)\nReturn the InEndpoint or OutEndpoint with the specified address.\n\n### .endpoints\nList of endpoints on this interface: InEndpoint and OutEndpoint objects.\n\n### .interface\nInteger interface number.\n\n### .altSetting\nInteger alternate setting number.\n\n### .setAltSetting(altSetting, callback(error))\nSets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.\n\n### .claim()\nClaims the interface. This method must be called before using any endpoints of this interface.\n\n### .release([closeEndpoints], callback(error))\nReleases the interface and resets the alternate setting. Calls callback when complete.\n\nIt is an error to release an interface with pending transfers. If the optional closeEndpoints parameter is true, any active endpoint streams are stopped (see `Endpoint.stopStream`), and the interface is released after the stream transfers are cancelled. Transfers submitted individually with `Endpoint.transfer` are not affected by this parameter.\n\n### .isKernelDriverActive()\nReturns `false` if a kernel driver is not active; `true` if active.\n\n### .detachKernelDriver()\nDetaches the kernel driver from the interface.\n\n### .attachKernelDriver()\nRe-attaches the kernel driver for the interface.\n\n### .descriptor\nObject with fields from the interface descriptor -- see libusb documentation or USB spec.\n\n  - bLength\n  - bDescriptorType\n  - bInterfaceNumber\n  - bAlternateSetting\n  - bNumEndpoints\n  - bInterfaceClass\n  - bInterfaceSubClass\n  - bInterfaceProtocol\n  - iInterface\n  - extra (Buffer containing any extra data or additional descriptors)\n\nEndpoint\n--------\n\nCommon base for InEndpoint and OutEndpoint, see below.\n\n### .direction\nEndpoint direction: `\"in\"` or `\"out\"`.\n\n### .transferType\nEndpoint type: `usb.LIBUSB_TRANSFER_TYPE_BULK`, `usb.LIBUSB_TRANSFER_TYPE_INTERRUPT`, or `usb.LIBUSB_TRANSFER_TYPE_ISOCHRONOUS`.\n\n###  .descriptor\nObject with fields from the endpoint descriptor -- see libusb documentation or USB spec.\n\n  - bLength\n  - bDescriptorType\n  - bEndpointAddress\n  - bmAttributes\n  - wMaxPacketSize\n  - bInterval\n  - bRefresh\n  - bSynchAddress\n  - extra (Buffer containing any extra data or additional descriptors)\n\n### .timeout\nSets the timeout in milliseconds for transfers on this endpoint. The default, `0`, is infinite timeout.\n\nInEndpoint\n----------\n\nEndpoints in the IN direction (device->PC) have this type.\n\n### .transfer(length, callback(error, data))\nPerform a transfer to read data from the endpoint.\n\nIf length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.\n\n`this` in the callback is the InEndpoint object.\n\n### .startPoll(nTransfers=3, transferSize=maxPacketSize)\nStart polling the endpoint.\n\nThe library will keep `nTransfers` transfers of size `transferSize` pending in\nthe kernel at all times to ensure continuous data flow. This is handled by the\nlibusb event thread, so it continues even if the Node v8 thread is busy. The\n`data` and `error` events are emitted as transfers complete.\n\n### .stopPoll(cb)\nStop polling.\n\nFurther data may still be received. The `end` event is emitted and the callback\nis called once all transfers have completed or canceled.\n\n### Event: data(data : Buffer)\nEmitted with data received by the polling transfers\n\n### Event: error(error)\nEmitted when polling encounters an error.\n\n### Event: end\nEmitted when polling has been canceled\n\nOutEndpoint\n-----------\n\nEndpoints in the OUT direction (PC->device) have this type.\n\n### .transfer(data, callback(error))\nPerform a transfer to write `data` to the endpoint.\n\nIf length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.\n\n`this` in the callback is the OutEndpoint object.\n\n### Event: error(error)\nEmitted when the stream encounters an error.\n\n### Event: end\nEmitted when the stream has been stopped and all pending requests have been completed.\n\n\nUsbDetection\n------------\n\n### usb.on('attach', function(device) { ... });\nAttaches a callback to plugging in a `device`.\n\n### usb.on('detach', function(device) { ... });\nAttaches a callback to unplugging a `device`.\n\n\nDevelopment and testing\n=======================\n\nTo build from git:\n\n\tgit clone --recursive https://github.com/nonolith/node-usb.git\n\tcd node-usb\n\tnpm install\n\nTo execute the unit tests, [CoffeeScript](http://coffeescript.org) is required. Run\n\n\tnpm test\n\nSome tests require an attached USB device -- firmware to be released soon.\n\nLimitations\n===========\n\nDoes not support:\n\n  - Configurations other than the default one\n  - Isochronous transfers\n\nLicense\n=======\n\nMIT\n\nNote that the compiled Node extension includes Libusb, and is thus subject to the LGPL.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/nonolith/node-usb/issues"
  },
  "homepage": "https://github.com/nonolith/node-usb#readme",
  "bundleDependencies": [
    "node-pre-gyp"
  ],
  "_id": "usb@1.1.2",
  "_from": "usb@*"
}
